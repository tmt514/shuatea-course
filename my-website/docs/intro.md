---
sidebar_position: 1
---

# 開始刷題之前

嗨大家好，歡迎一起跟我們刷題刷起來！

在開始刷題之前，我們可以先快速討論一下解題是怎麼回事。

一個解法的生成，雖然偶爾是神來一筆，但絕對不是空穴來風。
除了少數渾然天成的酷炫技巧以外，其餘的解法都是有跡可循。
因此，筆者想要透過這個簡單的筆記型態的文件，與大家分享在不同觀點下，可以用哪些思考方式來解決演算法與資料結構的實作題目。


## 關於這份筆記

我們將從傳統的演算法設計開始說起，最主要的是幫助自己重拾[分而治之與遞迴的計算思維](unit01-divide-and-conquer/divide-and-conquer.md)。尤其是遞迴方法，遞迴是初學程式設計的朋友們最難以理解的地方。然而在分而治之的過程中，輕巧地使用遞迴，會幫助我們更清晰地看到解題的重點。分而治之法與主定理，更能幫助我們分析一個演算法的時間複雜度（與空間複雜度）。

除了時間複雜度的分析以外，在演算法實作的過程中，如果我們能夠有效利用硬體的特性，便能使程式執行變得更快。從單顆中央處理器的[位元組計算思維](unit02-bit-tricks/bit-tricks.md)、除了記憶體和硬碟以外還考慮到快取記憶體的[多層次記憶體架構計算思維](unit03-memory-hierarchy)、到多處理器的[平行計算思維](unit04-parallel-computing)，都能讓一台電腦的計算資源發揮到極致。

如果要處理更大規模的資料，顯然單憑一台電腦已經無法滿足要求。Scale-Up 會遇到的種種問題不只是系統上的、也會影響到演算法的設計。因此面對使用網路作為資料傳輸與處理器之間的溝通媒介時，如果已具備了[分散式計算的思考方式](unit05-distributed-computing)與[非同步計算的思考方式](unit06-asynchronous-computing)，就會對解題相當有幫助。

看完了許多不同的計算模型後，再次回到演算法設計之路上，就可以理解許多不同的演算法，在不同的計算架構和需求下的優劣與取捨。這時候，適時地加入一點點的數學思考，就能解決更多的問題，比方說[組合最佳化的解題思維](unit07-combinatorial-optimization)與[凸函數最佳化的解題思維](unit08-convex-optimization)。
此外，在很多現實的應用中，我們並不要求一個演算法在任意時刻都必須是最有效率的。透過[引入亂數與隨機變數的解題思維](unit09-randomized-algorithms)，利用簡單的隨機演算法，可以大幅減少寫程式的力氣和除錯的時間，但又不會犧牲絕大多數時候的演算法效率或正確性。最後，想對付一些資訊理論中相當困難的問題，難以設計找出精確的最佳解、同時又很有效率的演算法時，採用[近似演算法與各種貪求思維](unit10-approximate-algorithms)也會是一些不錯的選擇。

---- 卡卡嗯 2021.07.26

![](https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg)