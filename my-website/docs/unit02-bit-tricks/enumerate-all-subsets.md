---
sidebar_position: 12
sidebar_label: "🟨 枚舉所有子集合"
---

# 枚舉所有子集合

對於一個 $\{0, 1, \ldots, n-1\}$ 的子集合 $S$，我們可以利用一個 $n$-位元的二進位數字來表示它。比方說，我們可以利用 $21 = ({\tt{00010101}})_2$ 來表示子集合 $\{0, 2, 4\}$：這是因為 $21 = 2^0+2^2+2^4$。

我們來考慮以下的問題：如果給定一個集合的二進位表示法，我們有沒有辦法來列出它的所有子集合呢？

:::note 枚舉所有子集合
給定一個集合 $S$ 的二進位表示法，列舉其所有子集合對應的二進位數值。

比方說輸入為 $21$ 的時候，輸出要包含這些數值 $[0, 1, 4, 5, 16, 17, 20, 21]$。
:::

## 方法 1：利用減一的特性

當我們把一個數值「減一」的時候，最低有效位元會變成 $0$，然後所有更低的位元都會變成 $1$。因此，這時候我們再拿原本的 $S$ 當作遮罩蓋上去，就可以把所有比當前最低位元還低的那些集合元素都抓回來，完成枚舉：

```cpp
vector<int> list_all_subset(int S) {
  vector<int> subsets = {S};
  while (subsets.back() != 0) {
    subsets.push_back((subsets.back() - 1) & S);
  }
  // 回傳的會是遞減的序列。
  return subsets;
}
```

## 方法 2：利用倍增的特性

我們可以逐步利用前一篇的「找出 LSB」率先把所有元素（以二進位方式）取出。
假設 $x$ 是其中一個集合 $S$ 內的元素，我們得知「所有 $S$ 的子集合」便是所有 $S$ 扣除 $x$ 的子集合，分別考慮「加入 $x$」或「不加入 $x$」兩種選擇所產生出的所有子集合。

```cpp
vector<int> list_all_subset(int S) {
  vector<int> subsets = {0};
  while (S != 0) {
    int x = (S & -S); // 找出 LSB。
    S -= x; // 把 LSB 從待考慮的集合中移除。
    int n = subsets.size();
    // 原本已經列出了所有不包含 x 的集合了，只需把加入 x 的情形考慮進去就行。
    for (int i = 0; i < n; ++i)
      subsets.push_back(subsets[i] + x);
  }
  return subsets;
}
```